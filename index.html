<!DOCTYPE html>
<html>
  <head>
    <!--Import Google Font-->
    <link href="https://fonts.googleapis.com/css?family=JetBrains Mono" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <!--Import materialize.css-->
    <link type="text/css" rel="stylesheet" href="css/materialize.min.css"  media="screen,projection"/>
    <link type="text/css" rel="stylesheet" href="css/custom_style.css"/>

    <style>
        body {
            font-family: 'JetBrains Mono';font-size: 20px;
        }
    </style>

    <!--Let browser know website is optimized for mobile-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  </head>

  <body>

    <ul class="sidenav" id="mysidenav">
        <li>
            <div class="user-view">
                <div class="background">
                    <img src="./media/pcb3.jpg">
                </div>
                <a href="#name"><span class="name white-text" style="font-size: 16px;">
                        <!-- &#1F3B9; -->
                        <em>Team Beathoven</em>
                        <i class="material-icons" style="position: absolute; left:180px; top:47px;">gradient</i>
                        <br>
                        </br>
                        <br>
                        </br>
                        Table of Contents
                        <br>
                        </br>
                    </span></a>
            </div>
        </li>
        <li><a class="sidenav-close" href="#intro"><i class="material-icons">filter_1</i>Introduction</a></li>
        <li><a class="sidenav-close" href="#work"><i class="material-icons">filter_2</i>Working Principle</a></li>
        <li><a class="sidenav-close" href="#comps"><i class="material-icons">filter_3</i>Components Required</a></li>
        <li><a class="sidenav-close" href="#circ"><i class="material-icons">filter_4</i>Circuit Connections</a></li>
        <li><a class="sidenav-close" href="#firm"><i class="material-icons">filter_5</i>Firmware</a></li>
        <li><a class="sidenav-close" href="#jour"><i class="material-icons">filter_6</i>Journey</a></li>
        <li><a class="sidenav-close" href="#ress"><i class="material-icons">filter_7</i>Results</a></li>
        <li><a class="sidenav-close" href="#conc"><i class="material-icons">filter_8</i>Conclusion</a></li>
        <li><a class="sidenav-close" href="#refs"><i class="material-icons">filter_9</i>References</a></li>
        <li><a class="sidenav-close" href="#mtt"><i class="material-icons">group</i>Meet the Team</a></li>
    </ul>

    <a href="#" data-target="mysidenav" class="btn sidenav-trigger" style="position:absolute; left:20px; top:40px;background-color: #2233dd;">
        <i class="material-icons" style="font-size: 30px;">menu</i>
    </a>

    <script>
        document.addEventListener('DOMContentLoaded', function(){
            var side = document.querySelectorAll('.sidenav');
            M.Sidenav.init(side)
        })    
    </script>

    <!--Main Heading-->
    <div align="center">
        <h2><b>ESE5190 Final Project</b></h2>
        <h3>Falling Piano Tiles</h3>
        <h6>Ruturaj A. Nanoti  &emsp; &emsp; Siddhant Mathur &emsp; &emsp; Arnav Gadre</h6>
    </div>

    <!-- Aligning all the text with padding -->
    <!-- <top right bottom left> -->
    <div style="padding: 25px 100px 75px 100px;" align="justify">
    
        <h4><a name="intro" style="color: #000000;">Introduction</a></h4>
        <p>
            The <em>PIO</em> module on the <em>RP2040</em> is quite a powerfull peripheral, 
            especially in terms of carrying out tasks that require precise timings and 
            <em>GPIO</em> control. These tasks include handling communication protocols
            such as SPI, I2C, etc. In this project, we have utilized these capabilities
            of the PIO and the RP2040 as a whole to drive a 640x480 VGA display, and emulate
            the famous game - <em>Piano Tiles</em> integrated with spatial audio to provide an
            immersive experience. In the game, the user needs to intercept the falling tiles
            on the screen using a small base tile that is as the name suggests is present at
            the bottom of the screen. Each time a tile is intercepted a particular note is played.
            The spatial audio like effect is created based on which side the user intercepts the tile,
            i.e. if the tile is intercepted on the left side of the screen, the user will feel that the
            audio is coming from the left side and vice-versa for the right side. Headphones were used
            to implement this feature, driven using the <em>PWM</em> peripheral on the RP2040.
        </p>

        <p>The repository containing the code is availabe on 
        <code>GitHub</code> can be accessed by clicking
        <a href="https://github.com/team-beathoven/ESE5190-Final-Project"><u>here</u></a>.</p>

        <p style="margin-bottom: 1.5cm;">
            To get a little motivation for diving further into this, let's have a look at
            the end result.
        </p>

        <div align="center" style="margin-bottom: 2cm;">
        <video class="responsive-video" width="960" height="720" controls>
            <source src="./media/VGA.mov" type="video/mp4">
        </video>
        </div>

        <h4><a name="work" style="color: #000000;">Working Principle</a></h4>
        
        <p>
            For a detailed understanding of every component we will look at each of the features incorporated
            one by one.

            <ul>
                <li style="margin-bottom: 1cm;list-style-type: initial;list-style-position: inside;padding-left: 5px;"><b>VGA</b>
                <p style="margin-bottom: 2cm;">
                    First up is the VGA display. The VGA protocol works based on a few very precisely timed signals/pulses, which
                    can be seen in the figure below.
                </p>
                
                <div align="center" style="margin-bottom: 2cm;">
                    <img src="./media/protocol.png" width="720" height="480">
                </div>

                <p>
                    Here the <code>HSYNC</code> and <code>VSYNC</code> signals play a major role in terms of communicating
                    with the display and deciding both the temporal and spatial placement of pixels. The former has control
                    over when a new row of pixels should be displayed, and the latter controls when a new frame needs to come
                    in. All of this is controlled by the PIO module on the RP2040, which runs at a clock speed of 25MHz.The whole 
                    protocol can be explained in brief as follows:

                    <ol style="list-style-position: inside;">
                        <li style="list-style-position: outside;margin-left: 20px;"> 
                            Our display has a resolution of 640x480, as stated earlier, and hence the <code>HSYNC</code>
                            signal as the name suggests (<em>Horizontal Sync</em>) needs to be high for 640 clock cycles.
                        </li>

                        <li style="list-style-position: outside;margin-left: 20px;">
                            Our <code>HSYNC</code> signal is active-high and starts out as <code>HIGH</code>. During this
                            time, the <code>R</code>, <code>G</code> and <code>B</code> pins are set to varying volatages
                            between 0 and 0.7V, in every clock cycle.
                        </li>

                        <li style="list-style-position: outside;margin-left: 20px;">
                            Once a row of pixels is complete, the <code>HSYNC</code> enters into its <em>front porch</em>, for
                            which it goes to a <code>LOW</code> state for 16 clock cycles. Similarly it then moves onto the
                            <em>sync Pulse</em> and <em>back porch</em> part of the protocol and behaves as shown in the figure
                            above.
                        </li>

                        <li style="list-style-position: outside;margin-left: 20px;">
                            On the other hand as stated earlier the <code>VSYNC</code> (vertical sync) controls the frame. So,
                            during the whole <code>HSYNC</code> operation, the <code>VSYNC</code> remains <code>HIGH</code>.
                        </li>

                        <li style="list-style-position: outside;margin-left: 20px;">
                            The <code>VSYNC</code> signal also has the <em>front porch</em>, <em>sync pulse</em>, and the 
                            <em>back porch</em> part to it, and behaves based on the diagram displayed above, i.e. it stays
                            at a <code>HIGH</code> state during its <em>front porch</em> for 10 lines (time needed for the
                            <code>HSYNC</code> signal to go through 10 rows), and so on.
                        </li>
                    </ol>
                </p>
                </li>
                
                <li style="margin-bottom: 1cm;list-style-type: initial;list-style-position: inside;padding-left: 5px;"><b>Joystick</b>
                    <p style="margin-bottom: 2cm;">
                        The Joystick is a part of the user interface and enables the user to interact with the game. We used a
                        dual-axis analog joystick for our game, that spit out values based on its current position. Since, we only
                        needed a single DOF (Degree of freedom) for playing the game, we did not need data from both the axes of the
                        joystick.
                    </p>
                        
                    <div align="center" style="margin-bottom: 2cm;">
                        <img src="./media/joystick.png" width="150" height="150">
                    </div>

                    <p>
                        The joystick is connected with an onboard ADC on the RP2040, which converts the analog signal obtained from
                        the joystick into discrete digital levels. Here, we have used a <em>12-bit</em> value to represent the 
                        analog data. Hence, the values from the joystick had a range of 0 to 4095. Once we had the values from
                        the ADC, with some testing we caliberated the joystick based on the requirement for the game. Then the
                        data was mapped to a range of 0 to 50. Finally, after that based on that value the position of the joystick
                        was determined.
                    </p>
                </li>
                
                <li style="margin-bottom: 1cm;list-style-type: initial;list-style-position: inside;padding-left: 5px;"><b>PWM</b>
                <p>
                    Now we move on to the audio part of the game from the display.The RP2040 doesn't have a DAC onboard,
                    so we tried to use the PWM peripheral to generate audio notes. This was possible by encoding the notes into
                    a series of duty cycle values and storing it to an array, which can be accessed by the main code and played
                    whenever a tile is intercepted. Also, note that using a single PWM cycle for each value in the array will not create
                    a analog like sound effect, since we need some sort of persistence to emulate actual audio. Therefore, each
                    value in the array is played for 8 cycles to emulate that persistence of sound. This will become more apparent 
                    and clear once we take a look at the code.
                </p>
                </li>
            </ul>
        
        </p>

        <h4><a name="comps" style="color: #000000;">Components Required</a></h4>

            <ul>
                <li style="list-style-type: initial;list-style-position: inside;padding-left: 5px;">RP2040 based Development Board</li>
                <li style="list-style-type: initial;list-style-position: inside;padding-left: 5px;">VGA Cable</li>
                <li style="list-style-type: initial;list-style-position: inside;padding-left: 5px;">Dual-Axis Analog Joystick</li>
                <li style="list-style-type: initial;list-style-position: inside;padding-left: 5px;">Resistors - 3 (330 Ohm)</li>
                <li style="list-style-type: initial;list-style-position: inside;padding-left: 5px;">Wired Headphones</li>
                <li style="list-style-type: initial;list-style-position: inside;padding-left: 5px;">Female Audio Jack</li>
                <li style="list-style-type: initial;list-style-position: inside;padding-left: 5px;">Jumper Wires</li>
            </ul>

            <h4><a name="circ" style="color: #000000;">Circuit Connections</a></h4>

            <h4><a name="firm" style="color: #000000;">Firmware</a></h4>

            <p>
                Now let's take a look at the code that's driving our RP2040. Here also, we will split our code overview into
                smaller sections.
            </p>

            <ul>
                <li style="list-style-type: initial;list-style-position: inside;padding-left: 5px;"><b>Including the Necessary Libraries</b>
                    <p>
                    The following code snippet shows some of the standard as well as the hardware libraries that
                    we are going to use in our code. The hardware libraries included are a part of the <code>PICO-SDK</code>
                    that abstract register access commands for that particular peripheral into functions and make them
                    available to the user. So, here we are using the <code>adc</code>, <code>pio</code>, <code>dma</code>,
                    <code>irq</code> (interrupts) and the <code>pwm</code> peripheral. Finally, the <code>vga_graphics</code>
                    library that we are using is created by <a href="https://vanhunteradams.com/"><u>Hunter Adams</u></a>,
                    which can be found <a href="https://vanhunteradams.com/Pico/VGA/VGA.html"><u>here</u></a>.
                    </p>
                </li>

            <pre>
                <code>
#include "vga_graphics.h"
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "pico/stdlib.h"
#include "hardware/pio.h"
#include "hardware/dma.h"
#include "hardware/adc.h"
#include "registers.h"
#include "hardware/irq.h"  // interrupts
#include "hardware/pwm.h"  // pwm 
#include "hardware/sync.h" // wait for interrupt 
                </code>
            </pre>


            <li style="list-style-type: initial;list-style-position: inside;padding-left: 5px;"><b>Macros and Global Variables</b>
                    <p>
                    Now, we define some macros and global variables that will be used by our code. As described earlier, headphones are
                    used to emulate the spatial audio aspect of the game, and to achieve this we control the pins connected to the
                    left and right channels of the headphones. Therefore, two macros named <code>AUDIO_PIN_LEFT</code> and
                    <code>AUDIO_PIN_RIGHT</code> are created to improve the code readability and portability. Finally there is another
                    macro named <code>DELAY_CYCLES</code> which controls the delay between the left and right audio channel. As mentioned
                    above we encoded our audio notes into an array that contains the duty cycle information for creating a PWM signal. This
                    array needs to be accessed by our main code to play the actual notes, so we placed the array into a header file and included
                    that into the source file. Finally, the global variables namely <code>wav_position</code>, <code>flag_start</code>,
                    <code>audio_note_indx</code> and <code>interception_side</code> are used by the interrupt service routines, and the
                    function that each of them perform will be explained in later sections.
                    </p>

            <pre>
                <code>
// Audio PIN is to match some of the design guide shields. 
#define AUDIO_PIN_LEFT 28  // you can change this to whatever you like
#define AUDIO_PIN_RIGHT 15  // you can change this to whatever you like
#define DELAY_CYCLES 5

#include "audio_notes/A_major.h"
#include "audio_notes/E_major.h"
#include "audio_notes/B_major.h"
#include "audio_notes/Din_2.h"
#include "audio_notes/Tin_2.h"
#include "audio_notes/Na_2.h"
int wav_position = 0;
int flag_start = 0;
int audio_note_indx = 0;
int interception_side = 0;
                </code>
            </pre>

            <p>
            Apart from this some macros are defined for determining the static (like the x coordinate of the falling tiles in each column) 
            coordinates for the base tile and the tiles falling in each column. The macros <code>LEFT_VERT_TILES</code>, 
            <code>MID_VERT_TILES</code>, and <code>RIGHT_VERT_TILES</code> are defined to configure the x coordinate (the top-left vertex)
            of the tile in the left, middle and the right side respectively.
            </p>

            <pre>
                <code>
// Define the co-ordinates for the Tiles and the Joystick controlled base.
#define LEFT_VERT 150
#define MID_VERT 290
#define RIGHT_VERT 430

#define LEFT_VERT_TILES 160
#define MID_VERT_TILES 300
#define RIGHT_VERT_TILES 440

#define RESTART_PIN 4
#define RESTART_PIN_REG ((volatile uint32_t *)(IO_BANK0_BASE + 0x010))
                </code>
            </pre>

            <p style="margin-bottom: 1cm;">
            A <em>restart</em> button is integrated in the game to as the name suggests restart the game once the game is over, i.e. a tile
            is missed. This prevents the need to reset the microcontroller every time the game ends. To enable, this operation a switch or
            push button is connected to a <code>GPIO</code> pin on the RP2040, which is polled once the game is over to determine when to
            restart the game.
            </p>
            </li>
            
            <li style="list-style-type: initial;list-style-position: inside;padding-left: 5px;"><b>PWM Interrupt Handlers</b>
                    <p>
                    For controlling the left and right channels of the headphones, we have configured 2 separate <code>PWM</code>
                    channels with interrupts. Following is the interrupt handler or the interrupt service routine for the <code>PWM</code> 
                    pin that is connected to the left channel of the headphone. This function defines the tasks that need to be carried out
                    once a single PWM cycle completes, i.e. after one data element from the array that stores the audio information is played.
                    </p>

                    <p>
                    Here we can see that the <code>wav_position</code> variable is used to index the data array that contains our
                    audio note. Note that each data element in the array is played 8 times, to create a persistence effect, because a simple
                    PWM signal is very "sharp" in a sense, and this gives us a sort of smoother effect. Hence, we right shift the index by 3.
                    The <code>WAV_DATA_LENGTH</code> variable holds the length of the array, and therefore we left shift it by 3. Keep in mind
                    that left shifting a number increases it and right shifting a number decreases it. The <code>PWM</code> is a <em>free-running</em>
                    module and some sort of control is needed on the audio since we only want it to play once a tile is intercepted. This is where the
                    <code>flag_start</code> variable comes into play, it determines whether an audio needs to be played or not. If not the
                    <code>GPIO</code> pin connected to that channel is set to a <code>LOW</code> state. A brief description of all the steps
                    this function performs is as follows:
                    </p>
                    <ul style="list-style-position: inside;">
                    <li style="list-style-type: initial;list-style-position: outside;margin-left: 20px;">
                        So firstly, we check that we are not accessing elements that are out of the array bounds, along with that we also need to
                        make sure that the <code>flag_start</code> variable is set indicating that an audio note needs to be played.
                    </li>
                    <li style="list-style-type: initial;list-style-position: outside;margin-left: 20px;">
                        We have 6 audio notes to choose from and at a time or in a game instance only 3 are required one for each column. Now, the
                        variable named <code>audio_note_indx</code> is used to determine which of the 3 notes needs to be accessed currently. For
                        example we have used the <code>NA</code>, <code>DIN</code> and <code>TIN</code> notes and <code>0</code> is assigned to the
                        note <code>NA</code>, <code>1</code> is assigned to the note <code>DIN</code> and so on.
                        Some of these notes are generated using the Indian classicial musical instrument named <em>Tabla</em>.
                    </li>
                    <li style="list-style-type: initial;list-style-position: outside;margin-left: 20px;">
                        Then, we check which side the tile has been intercepted on based on the value that is held in the 
                        <code>interception_side</code> side variable. It has a value of <code>0</code> if the tile is
                        intercepted on the left side, a value of <code>1</code> if the tile is intercepted in the middle
                        and a value of <code>2</code> if the tile has been intercepted on the right (you get the idea).
                        To emulate spatial audio the side that the tile has been hit, needs to produce a <em>louder</em>
                        sound as compared to the opposite side, i.e. if the tile has been intercepted on the left, the left
                        channel should have a higher amplitude as compared to the right channel. Similarly, in terms of delay,
                        for the same example, the sound should reach the left channel first and then the right  channel.
                        Therefore, for amplitude modulation, we add or subtract to the <code>ON</code> time present in the array,
                        and for delay we manipulate the <code>wav_position</code> index such that the same audio note played in
                        the left and right channel feels like it is shifted to the right in time.
                    </li>
                    <li style="list-style-type: initial;list-style-position: outside;margin-left: 20px;">
                        Finally, in the <code>else</code> condition, when the <code>flag_start</code> variable is not set,
                        as mentioned earlier we set the <code>GPIO</code> pin to <code>0</code> and increment our <code>audio_note_indx</code>
                        variable untill the final note is reached, in which case it is reset to <code>0</code>. Similarly, the <code>wav_position</code>
                        is also set to <code>0</code> here. Note that the <code>flag_start</code> variable is unset to enable that control over
                        when the audio notes are played.
                    </li>
                    </ul>

            <pre>
                <code>
void pwm_interrupt_handler() {
    pwm_clear_irq(pwm_gpio_to_slice_num(AUDIO_PIN_LEFT));    
    if (wav_position < (WAV_DATA_LENGTH<<3) - 1 && flag_start == 1) { 
        // set pwm level 
        // allow the pwm value to repeat for 8 cycles this is >>3 
        if (audio_note_indx == 0) {
            if (interception_side == 0 || interception_side == 1) {
                pwm_set_gpio_level(AUDIO_PIN_LEFT, WAV_DATA_NA[wav_position>>3]+20);
            } else {
                if (((wav_position>>3) - DELAY_CYCLES) <= 0) {
                    pwm_set_gpio_level(AUDIO_PIN_LEFT, 0);
                } else {
                    pwm_set_gpio_level(AUDIO_PIN_LEFT, WAV_DATA_NA[(wav_position>>3) - DELAY_CYCLES]-20);

                }
            }
        } else if (audio_note_indx == 1) {
            if (interception_side == 0 || interception_side == 1) {
                pwm_set_gpio_level(AUDIO_PIN_LEFT, WAV_DATA_DIN[wav_position>>3]+20);
            } else {
                if (((wav_position>>3) - DELAY_CYCLES) <= 0) {
                    pwm_set_gpio_level(AUDIO_PIN_LEFT, 0);
                } else {
                    pwm_set_gpio_level(AUDIO_PIN_LEFT, WAV_DATA_DIN[(wav_position>>3) - DELAY_CYCLES]-20);
                }
            }
        } else {
            if (interception_side == 0 || interception_side == 1) {
                pwm_set_gpio_level(AUDIO_PIN_LEFT, WAV_DATA_TIN[wav_position>>3]+20);
            } else {
                if (((wav_position>>3) - DELAY_CYCLES) <= 0) {

                    pwm_set_gpio_level(AUDIO_PIN_LEFT, 0);

                } else {
                    pwm_set_gpio_level(AUDIO_PIN_LEFT, WAV_DATA_TIN[(wav_position>>3) - DELAY_CYCLES]-20);
                }
            }
        }
        wav_position++;
    } else {
        // reset to start
        pwm_set_gpio_level(AUDIO_PIN_LEFT, 0);  
        if (flag_start == 1) {
            wav_position = 0;
            flag_start = 0;
            if (audio_note_indx < 2) {
                audio_note_indx += 1;
            } else {
                audio_note_indx = 0;
            }
        }
    }
}
                </code>
            </pre>

            <p>
            A very similar approach is taken for implementing the interrupt handler for the right channel of the headphone.
            </p>

            <pre>
                <code>
void pwm_interrupt_handler_2() {
    pwm_clear_irq(pwm_gpio_to_slice_num(AUDIO_PIN_RIGHT));    
    if (wav_position < (WAV_DATA_LENGTH<<3) - 1 && flag_start == 1) { 

        // set pwm level 
        // allow the pwm value to repeat for 8 cycles this is >>3 
        if (audio_note_indx == 0) {
            if (interception_side == 1 || interception_side == 2) {
                pwm_set_gpio_level(AUDIO_PIN_RIGHT, WAV_DATA_NA[wav_position>>3]);
            } else {
                if (((wav_position>>3) - DELAY_CYCLES) <= 0) {
                    pwm_set_gpio_level(AUDIO_PIN_RIGHT, 0);
                } else {
                    pwm_set_gpio_level(AUDIO_PIN_RIGHT, WAV_DATA_NA[(wav_position>>3) - DELAY_CYCLES]-80);
                }
            }
        } else if (audio_note_indx == 1) {
            if (interception_side == 1 || interception_side == 2) {
                pwm_set_gpio_level(AUDIO_PIN_RIGHT, WAV_DATA_DIN[wav_position>>3]);
            } else {
                if (((wav_position>>3) - DELAY_CYCLES) <= 0) {
                    pwm_set_gpio_level(AUDIO_PIN_RIGHT, 0);
                } else {
                    pwm_set_gpio_level(AUDIO_PIN_RIGHT, WAV_DATA_DIN[(wav_position>>3) - DELAY_CYCLES]-80);
                }
            }
        } else {
            if (interception_side == 1 || interception_side == 2) {
                pwm_set_gpio_level(AUDIO_PIN_RIGHT, WAV_DATA_TIN[wav_position>>3]);
            } else {
                if (((wav_position>>3) - DELAY_CYCLES) <= 0) {
                    pwm_set_gpio_level(AUDIO_PIN_RIGHT, 0);
                } else {
                    pwm_set_gpio_level(AUDIO_PIN_RIGHT, WAV_DATA_TIN[(wav_position>>3) - DELAY_CYCLES]-80);
                }
            }
        }
        wav_position++;
    } else {
        // reset to start
        pwm_set_gpio_level(AUDIO_PIN_RIGHT, 0);  
        if (flag_start == 1) {
            wav_position = 0;

            flag_start = 0;
            if (audio_note_indx < 2) {
                audio_note_indx += 1;
            } else {
                audio_note_indx = 0;
            }
        }
    }
}
                </code>
            </pre>


            <li style="list-style-type: initial;list-style-position: inside;padding-left: 5px;"><b>Processing the ADC Output</b>
                <p>
                Now, let's move onto implementing the base tile, i.e. user interaction functionality. Here, we need to move the base
                tile based on the current position of the joystick. To do this, firstly the raw <code>adc</code> value needs to be 
                read from the <code>GPIO</code> pin. We have used <code>ADC0</code>, so the function <code>adc_select_input(0)</code>
                will select the <code>adc</code> for us. The raw value read from the <code>adc</code> is stored in a variable named
                <code>adc_x_raw</code> and this value is used to calliberate the joystick. A range of values is used in this process
                for thresholding and reducing the <em>de-bouncing</em> effect. A 12-bit <code>ADC</code> is used
                to descritize the raw values obtained from the joystick. Once the calliberation is done, the resulting value is mapped
                to a range of 0 to 100, and based on this value thresholding is done once again to determine where the base tile needs
                to be positioned. The <code>fillRect</code> function is a part of the <code>vga_graphics</code> library that enables us
                to draw a filled rectangle on the screen. This is done by using two <code>for</code> loops, and calling the 
                <code>drawPixel</code> function in each iteration, which in-turn populates or updates the <code>VGA_DATA_ARRAY</code>
                based on the color and position of the pixel. Therefore, at the <code>fillRect</code> level, it requires the top-left
                vertex of the rectangle that needs to be drawn as its arguments, along with the width and height of the rectangle and
                finally the color that the rectangle needs to be filled with. At the end, we sleep for some time and return the 
                <code>adc_x</code> variable. This will be required for determining the side on which the tile was intercepted or where
                the base tile is in reference to the current state of the screen.
                </p>

            <pre>
                <code>
// Define a function to draw the base tile, based on the current joystick
// position.
uint act_adc() {
    adc_select_input(0);
    uint adc_x_raw = adc_read();
    uint adc_x = 0;

    if (adc_x_raw > 1600 && adc_x_raw < 2400) {
        adc_x = 2048;
    } else {
        adc_x = adc_x_raw;
    }

    adc_x = (adc_x * 100) / 4095;

    printf("%d, %d\n", adc_x, adc_x_raw);
    

    if (adc_x == 50){
        fillRect(MID_VERT,460,60,20,WHITE);
        fillRect(LEFT_VERT,460,60,20,0);
        fillRect(RIGHT_VERT,460,60,20,0);
    }
    else if (adc_x > 50) {
        fillRect(RIGHT_VERT,460,60,20,WHITE);
        fillRect(LEFT_VERT,460,60,20,0);
        fillRect(MID_VERT,460,60,20,0);
    }else if (adc_x < 50) {
        fillRect(LEFT_VERT,460,60,20,WHITE);
        fillRect(MID_VERT,460,60,20,0);
        fillRect(RIGHT_VERT,460,60,20,0);
    }
    sleep_ms(10);
    return adc_x;
}
                </code>
            </pre>
            </li>

            <li style="list-style-type: initial;list-style-position: inside;padding-left: 5px;"><b>Helper Functions for Animation and Score Tracking</b>
                <p>
                For a immersive and enjoyable experience the game animation needs to be engaging, lag-free and smooth. This task of making
                the tiles fall was repetitive in the sense that every tile needed to have this animation, hence we created a helper function that
                would avoid code repetition and improve readability. The <code>draw_fill_rect</code> function takes in an arguments the
                parameters required for the <code>fillRect</code> function, and another argument named <code>inc_dec</code>. As explained above
                the <code>fillRect</code> function draws rectangles on the screen, which now need to be animated. Hence, to do this, we
                first thought of erasing the whole drawn rectangle and creating another one at a position lower than its last position to
                give an impression that the tile is falling. However, this did not pan out well, it lead to choppy animation since erasing
                the whole rectangle was taking up quite a bit of time. Therefore, we decided to erase a small rectangle from the top of the
                tile and create another at the bottom of the tile, to emulate a falling tile. So, now every time the tile needs to descend
                a small part of it is erased from the top and a similar portion is created at the bottom. This is where the <code>inc_dec</code>
                parameter comes into play, it decides the height of the small portion that is going to be erased at the top and created at the
                bottom.
                </p>

            <pre>
                <code>
// Helper function to abstract the animation.
void draw_fill_rect(short x, short y, short w, short h, char color, short inc_dec){
    fillRect(x,y,w,h,color);
    fillRect(x,y,w,inc_dec,0);
    fillRect(x,y+h,w,inc_dec,color);
    sleep_ms(10);

}           
                </code>
            </pre>
            
            <p>
            The score needs to be updated every time a tile is intercepted, to do this, firstly the entire area that shows the score is
            erased. For displaying score we need digits, which are passed as characters to the <code>drawChar</code> function. We decided
            to have a maximum of 3 digits to represent the score, and hence created a character array of size 3 that stores each digit of 
            the current score which is passed as a parameter to the <code>update_score</code> function. Each digit is extracted from the 
            current score using the <code>%</code> operation with <code>10</code>, and each digit becomes an element in the character array.
            Then the <code>drawChar</code> function is called thrice to draw each digit on the screen.
            </p>

            <pre>
                <code>
// Helper function to keep track of the user's score.
void update_score(uint score){
    fillRect(30,60,240,20,0);
    /* setCursor(30, 30); */
    /* setTextSize(3); */
    char str_score[3] = {'0', '0', '0'};
    str_score[2] = (score % 10) + '0';
    str_score[1] = ((score/10) % 10) + '0';

    str_score[0] = (((score/10)/10) % 10) + '0';
    drawChar(30, 60, str_score[0], WHITE, 0, 2);
    drawChar(45, 60, str_score[1], WHITE, 0, 2);
    drawChar(60, 60, str_score[2], WHITE, 0, 2);
}
                </code>
            </pre>
            </li>


            <li style="list-style-type: initial;list-style-position: inside;padding-left: 5px;"><b>The main Function</b>
                <p>
                </p>

            <pre>
                <code>
                </code>
            </pre>
            </li>
            
            </li>

        <h4><a name="jour" style="color: #000000;">Journey</a></h4>

        <h4><a name="ress" style="color: #000000;">Results</a></h4>
        
        <h4><a name="conc" style="color: #000000;">Conclusion</a></h4>

        <h4><a name="refs" style="color: #000000;">References</a></h4>

        <ul>
            <li style="list-style-type: initial;list-style-position: inside;padding-left: 6px;">
                <a href="https://vanhunteradams.com/Pico/VGA/VGA.html"><u>https://vanhunteradams.com/Pico/VGA/VGA.html</u></a>
            </li>
            <li style="list-style-type: initial;list-style-position: inside;padding-left: 6px;">
                <a href="https://github.com/rgrosset/pico-pwm-audio"><u>https://github.com/rgrosset/pico-pwm-audio</u></a>
            </li>
        </ul>

        <h4><a name="mtt" style="color: #000000;">Meet the Team</a></h4>

    </div>

    <!--JavaScript at end of body for optimized loading-->
    <script type="text/javascript" src="js/materialize.min.js"></script>
  </body>
</html>
